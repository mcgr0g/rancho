<!-- MarkdownTOC -->

- wtf
- [возможные проблемы](#troubleshooting)
    - криво создались пользователи
    - [ошибки окончания строки](#win-cr)
- [параметры развертывания buben в rancho](#letsgo)
    - [Группы пользователей](#usergroups)
    - [Типовые пользователи](#users)
    - [Проектные роли на сервере](#roles)
        - [По простому](#roles.fast)
        - [По умнее](#roles.smart)
        - [По сложному](#roles.bigdeal)

<!-- /MarkdownTOC -->


# wtf
Скрипты для первичного конфигурирования системы после установки.
Используется ролевая модель веб-студии на шаред хостинге.
Любое сходство со знакомыми персонажами возможно, так же как и подобранные имена компонентов - для простоты запоминания.

# возможные проблемы [troubleshooting]
## криво создались пользователи 
это потому что в скрипте инициализируется импорт блока приватных данных и они могут быть переопределены

## ошибки окончания строки [win-cr]
дословно `users_init.sh: line 8: $'\r': command not found`
возникает, если вы не сделали настройку [git](https://github.com/mcgr0g/dotfiles/blob/master/.gitconfig#L17) на windows машине. Решение на десктопе:
`git config --global core.autocrlf input`
и перезалить в репозитарий. Или сделать на сервере
`sed -i 's/\r$//' users_init.sh`

# параметры развертывания buben в rancho [letsgo]

## Группы пользователей [usergroups]

Простейшая модель ИБ: есть ключ - твори непотребство, иначе - только наблюдай.
Под ключом подразумевается возможность авторизоваться по ssh key.
Под непотребством подразумевается возможность работать от root.
Таким образом будут следующие группы пользователей:

* **sudo**- судоеры, привилегированные рутом пользователи

* **keyonly**- ключники, те, кому дали ssh ключи. Ну или от vpn.

* **dev** - разрабы, могут редактировать исходники и статические данные. Те, кто в ней не состоят - не должны даже иметь возможность читать статику, если он не являются владельцами каталога

* **www-data** - запускает скрипты, создает логи, генерирует и сохраняет картинки для капчи, создает текстовые файлы с кешем и т.д.

## Типовые пользователи [users]

будут выглядеть так:

* **enot** - входит в sudo, keyonly, dev, www-data

* **lisa**- входит в sudo, keyonly, dev, www-data

* **gomer** - входит в www-data, keyonly

* **march**- входит в www-data, keyonly

* **bender**- входит в keyonly, www-data

* **stub** - никуда не входит

Как видно, Енот и Лиса - разрабы.
Персонажи по проще с доступами попроще: Гомер и Марч. Если эти роли следует выдавать клиентам или контент менеджерам для целей правки контента или просто попыриться на процесс разработки.

Робот Бендер будет отрабатывать сохраненные скрипты и сценарии.

Обрезанный (stub) будет служить только для целей авторизации из сомнительных источников на сервере и дальнейшего перелогирования в разработчика. Ну или админа.

Есть заготовка скрипта [создания](https://github.com/mcgr0g/rancho/blob/master/firstrun/users_sys.sh) пользователей
их ключей и параметров [авторизации](https://github.com/mcgr0g/rancho/blob/master/firstrun/users_ssh.sh)
и [конфигурирования](https://github.com/mcgr0g/rancho/blob/master/firstrun/users_ssh.sh) сервера для авторизации

## Проектные роли на сервере [roles]

### По простому [roles.fast]

В первом приближении хочется ставить на весь проект [код прав доступа](http://mcgrog.blogspot.ru/2013/10/blog-post_28.html) 674:

1. владелец читает и пишет

2. группа разрабов - делает все

3. остальные - только читают

### По умнее [roles.smart]

Но если Гомер и Марч клиенты из разных компаний, реализованных на одном сервере, то все как то грустно - один может подсмотреть данные другого. И поэтому нужно ограничить их на чтение только своих проектных каталогов, используя [suid](https://ru.wikipedia.org/wiki/Suid) bit.

Допустим, Гомер владелец проекта и каталога projectMagazSobak, соответственно, он будет владельцем каталога с правами чтение и запись. Группа каталога будет одной из групп для разрабов, чтобы они могли и читать, и писать и исполнять файлы (или dev или www-data).

Необходимо рекурсивно  унаследовать группу для разработчиков, установив SGID бит.

Необходимость рекурсивно  унаследовать владельца, установив SUID, находится под сомнением и вот почему: при установке SUID процесс будет запускать все файлы из-под Гомера, а у него нет прав на исполнение. Иначе разработчики будут вставлять себе палки в колеса

Таким образом подходит код 2670

### По сложному [roles.bigdeal]

Если углубиться в тематику, можно найти [много](https://toster.ru/answer?answer_id=153551#answers_list_answer) [советов](http://forum.ubuntu.ru/index.php?topic=280804.msg2210354#msg2210354). И в итоге все сводится к системному [ACL](https://wiki.archlinux.org/index.php/Access_Control_Lists_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)). Особенности использования утилиты setfacl будет рассмотрено позже. А пока рассмотрим из чего состоит типовой projectMagazSobak: обычно есть несколько вложенных каталогов и права должны быть разные.

* project - Домен должен быть доступен на r только одному продуктологу, так как внутрь не провалиться если не прочитать содержимое. И наверно продуктолог захочет хранить всякий мусор в корне, который не должен улетать в репозитарий.
Ставим 0710 gomer:gomer

    * src - исходники должны быть доступны на rwx только разработчикам.
Ставим 2470 gomer:dev

    * conf - должны быть доступны на r скриптам и rw разрабам. Но очень редко в конфигах есть конфигурационные скрипты для миграции, развертывания и прочего
Ставим 2470 gomer:dev

    * templates - html шаблоны, должны быть доступны на rw контентщику и скриптам.
Ставим 2670 gomer:www-data

    * static - должны быть доступны на r всем и на rw скриптам.
Ставим 0464 gomer:www-data

    * logs - логи должны быть доступны на r всем и на rw скриптам.
Ставим 0464 gomer:www-data
